name: Run Tests On Demand

on:
  workflow_dispatch:
    inputs:
      test_type:
        description: "Type of tests to run"
        required: true
        type: choice
        options:
          - unit
          - integration
          - e2e
          - all
      run_id:
        description: "Unique test run ID"
        required: true
        type: string

env:
  NODE_VERSION: "24.x"
  PNPM_VERSION: "10.19.0"

jobs:
  run-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    defaults:
      run:
        working-directory: ./lines-app

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "pnpm"
          # Explicitly point cache to the app's pnpm lockfile inside the monorepo
          cache-dependency-path: lines-app/pnpm-lock.yaml

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Generate Prisma Client
        run: pnpm db:generate
        env:
          POSTGRES_PRISMA_URL: ${{ secrets.POSTGRES_PRISMA_URL }}

      - name: Install Playwright browsers
        if: ${{ inputs.test_type == 'e2e' || inputs.test_type == 'all' }}
        run: pnpm exec playwright install --with-deps chromium

      - name: Run Unit Tests
        if: ${{ inputs.test_type == 'unit' || inputs.test_type == 'all' }}
        id: run_unit_tests
        continue-on-error: true
        run: |
          # Run tests with JSON reporter (outputs to stdout)
          pnpm test:unit --reporter=json --reporter=verbose > test-results-unit.json 2>&1 || TEST_EXIT_CODE=$?
          
          # Check if JSON file was created (vitest json reporter writes to file when outputFile is set)
          # If not, try to parse from stdout or create empty
          if [ ! -f test-results-unit.json ] || ! jq empty test-results-unit.json 2>/dev/null; then
            echo '{"testResults":[]}' > test-results-unit.json
          fi
          
          # Show test output for debugging
          cat test-results-unit.json | head -50 || true
          exit ${TEST_EXIT_CODE:-0}
        env:
          NEXT_PUBLIC_APP_URL: ${{ secrets.NEXT_PUBLIC_APP_URL || 'https://lines-app.vercel.app' }}

      - name: Run Integration Tests
        if: ${{ inputs.test_type == 'integration' || inputs.test_type == 'all' }}
        id: run_integration_tests
        continue-on-error: true
        run: |
          # Run tests with JSON reporter (outputs to stdout)
          pnpm test:integration --reporter=json --reporter=verbose > test-results-integration.json 2>&1 || TEST_EXIT_CODE=$?
          
          # Check if JSON file was created
          if [ ! -f test-results-integration.json ] || ! jq empty test-results-integration.json 2>/dev/null; then
            echo '{"testResults":[]}' > test-results-integration.json
          fi
          
          # Show test output for debugging
          cat test-results-integration.json | head -50 || true
          exit ${TEST_EXIT_CODE:-0}
        env:
          NEXT_PUBLIC_APP_URL: ${{ secrets.NEXT_PUBLIC_APP_URL || 'https://lines-app.vercel.app' }}

      - name: Run E2E Tests
        if: ${{ inputs.test_type == 'e2e' || inputs.test_type == 'all' }}
        id: run_e2e_tests
        continue-on-error: true
        run: |
          # Run Playwright tests - JSON reporter creates playwright-report/results.json
          pnpm test:e2e:production --reporter=json --reporter=list 2>&1 || TEST_EXIT_CODE=$?
          
          # Ensure playwright-report directory exists
          mkdir -p playwright-report
          
          # Check if results.json exists and is valid JSON
          if [ ! -f playwright-report/results.json ] || ! jq empty playwright-report/results.json 2>/dev/null; then
            echo '{"suites":[]}' > playwright-report/results.json
          fi
          
          # Show first part of results for debugging
          cat playwright-report/results.json | head -20 || true
          exit ${TEST_EXIT_CODE:-0}
        env:
          NEXT_PUBLIC_APP_URL: ${{ secrets.NEXT_PUBLIC_APP_URL || 'https://lines-app.vercel.app' }}

      - name: Parse Test Results
        id: parse_results
        if: always()
        continue-on-error: true
        run: |
          node << 'EOF'
          const fs = require('fs');
          const path = require('path');

          // Robust JSON extraction function that handles mixed output
          function extractJSON(content) {
            if (!content || typeof content !== 'string') {
              return null;
            }

            // First, try to parse the entire content as JSON (best case)
            try {
              const parsed = JSON.parse(content.trim());
              if (parsed && typeof parsed === 'object') {
                return parsed;
              }
            } catch (e) {
              // Not pure JSON, continue to extraction
            }

            // Find JSON object by matching balanced braces
            // Look for the pattern: { ... "testResults" ... }
            let braceCount = 0;
            let startIndex = -1;
            let inString = false;
            let escapeNext = false;

            for (let i = 0; i < content.length; i++) {
              const char = content[i];

              if (escapeNext) {
                escapeNext = false;
                continue;
              }

              if (char === '\\') {
                escapeNext = true;
                continue;
              }

              if (char === '"' && !escapeNext) {
                inString = !inString;
                continue;
              }

              if (inString) {
                continue;
              }

              if (char === '{') {
                if (braceCount === 0) {
                  startIndex = i;
                }
                braceCount++;
              } else if (char === '}') {
                braceCount--;
                if (braceCount === 0 && startIndex !== -1) {
                  // Found a complete object, check if it contains "testResults"
                  const candidate = content.substring(startIndex, i + 1);
                  if (candidate.includes('"testResults"')) {
                    try {
                      const parsed = JSON.parse(candidate);
                      if (parsed && typeof parsed === 'object' && parsed.testResults) {
                        return parsed;
                      }
                    } catch (e) {
                      // Invalid JSON, continue searching
                    }
                  }
                  startIndex = -1;
                }
              }
            }

            // Fallback: try to find JSON using a more precise regex (non-greedy)
            // Look for the smallest JSON object containing "testResults"
            const regex = /\{[^{}]*"testResults"[^{}]*\}/;
            let match = content.match(regex);
            if (!match) {
              // Try with nested braces using a more sophisticated approach
              const lines = content.split('\n');
              let jsonStart = -1;
              let jsonEnd = -1;
              for (let i = 0; i < lines.length; i++) {
                if (lines[i].trim().startsWith('{') && lines[i].includes('"testResults"')) {
                  jsonStart = i;
                  // Find the matching closing brace
                  let braceCount = 0;
                  for (let j = i; j < lines.length; j++) {
                    for (const char of lines[j]) {
                      if (char === '{') braceCount++;
                      if (char === '}') braceCount--;
                      if (braceCount === 0 && jsonStart !== -1) {
                        jsonEnd = j;
                        break;
                      }
                    }
                    if (jsonEnd !== -1) break;
                  }
                  if (jsonEnd !== -1) {
                    const candidate = lines.slice(jsonStart, jsonEnd + 1).join('\n');
                    try {
                      return JSON.parse(candidate);
                    } catch (e) {
                      // Continue searching
                    }
                  }
                }
              }
            } else {
              try {
                return JSON.parse(match[0]);
              } catch (e) {
                // Invalid JSON
              }
            }

            return null;
          }

          const testType = process.env.TEST_TYPE;
          let allResults = [];
          let total = 0;
          let passed = 0;
          let failed = 0;
          let skipped = 0;
          let totalDuration = 0;

          // Parse unit tests (Vitest JSON format)
          if (testType === 'unit' || testType === 'all') {
            try {
              const unitFile = path.join(process.cwd(), 'test-results-unit.json');
              if (fs.existsSync(unitFile)) {
                const content = fs.readFileSync(unitFile, 'utf8');
                const unitData = extractJSON(content);
                if (unitData && unitData.testResults && Array.isArray(unitData.testResults)) {
                  unitData.testResults.forEach(file => {
                    if (file.assertionResults && Array.isArray(file.assertionResults)) {
                      file.assertionResults.forEach(test => {
                        allResults.push({
                          testFile: file.name || 'unknown',
                          testName: test.fullName || test.title || 'unknown',
                          status: test.status === 'passed' ? 'passed' : test.status === 'failed' ? 'failed' : 'skipped',
                          duration: test.duration || 0,
                          error: test.failureMessages && test.failureMessages.length > 0 ? {
                            message: test.failureMessages[0],
                            stack: test.failureMessages.join('\n')
                          } : undefined
                        });
                        total++;
                        if (test.status === 'passed') passed++;
                        else if (test.status === 'failed') failed++;
                        else skipped++;
                        if (test.duration) totalDuration += test.duration;
                      });
                    }
                  });
                } else {
                  console.warn('Warning: Could not extract valid JSON from unit test results file');
                }
              }
            } catch (e) {
              console.error('Error parsing unit tests:', e.message);
              console.error('Stack:', e.stack);
            }
          }

          // Parse integration tests (Vitest JSON format)
          if (testType === 'integration' || testType === 'all') {
            try {
              const intFile = path.join(process.cwd(), 'test-results-integration.json');
              if (fs.existsSync(intFile)) {
                const content = fs.readFileSync(intFile, 'utf8');
                const intData = extractJSON(content);
                if (intData && intData.testResults && Array.isArray(intData.testResults)) {
                  intData.testResults.forEach(file => {
                    if (file.assertionResults && Array.isArray(file.assertionResults)) {
                      file.assertionResults.forEach(test => {
                        allResults.push({
                          testFile: file.name || 'unknown',
                          testName: test.fullName || test.title || 'unknown',
                          status: test.status === 'passed' ? 'passed' : test.status === 'failed' ? 'failed' : 'skipped',
                          duration: test.duration || 0,
                          error: test.failureMessages && test.failureMessages.length > 0 ? {
                            message: test.failureMessages[0],
                            stack: test.failureMessages.join('\n')
                          } : undefined
                        });
                        total++;
                        if (test.status === 'passed') passed++;
                        else if (test.status === 'failed') failed++;
                        else skipped++;
                        if (test.duration) totalDuration += test.duration;
                      });
                    }
                  });
                } else {
                  console.warn('Warning: Could not extract valid JSON from integration test results file');
                }
              }
            } catch (e) {
              console.error('Error parsing integration tests:', e.message);
              console.error('Stack:', e.stack);
            }
          }

          // Parse E2E tests (Playwright JSON format)
          if (testType === 'e2e' || testType === 'all') {
            try {
              const e2eFile = path.join(process.cwd(), 'playwright-report', 'results.json');
              if (fs.existsSync(e2eFile)) {
                const e2eData = JSON.parse(fs.readFileSync(e2eFile, 'utf8'));
                // Playwright JSON format has different structure
                if (e2eData.suites && Array.isArray(e2eData.suites)) {
                  e2eData.suites.forEach(suite => {
                    if (suite.specs && Array.isArray(suite.specs)) {
                      suite.specs.forEach(spec => {
                        if (spec.tests && Array.isArray(spec.tests)) {
                          spec.tests.forEach(test => {
                            const results = test.results || [];
                            const lastResult = results[results.length - 1];
                            allResults.push({
                              testFile: spec.file || 'unknown',
                              testName: spec.title || test.title || 'unknown',
                              status: lastResult?.status === 'passed' ? 'passed' : lastResult?.status === 'failed' ? 'failed' : 'skipped',
                              duration: lastResult?.duration || 0,
                              error: lastResult?.error ? {
                                message: lastResult.error.message,
                                stack: lastResult.error.stack
                              } : undefined
                            });
                            total++;
                            if (lastResult?.status === 'passed') passed++;
                            else if (lastResult?.status === 'failed') failed++;
                            else skipped++;
                            if (lastResult?.duration) totalDuration += lastResult.duration;
                          });
                        }
                      });
                    }
                  });
                }
              }
            } catch (e) {
              console.error('Error parsing E2E tests:', e.message);
            }
          }

          const results = {
            total,
            passed,
            failed,
            skipped,
            duration: Math.round(totalDuration),
            results: allResults
          };

          fs.writeFileSync('parsed-test-results.json', JSON.stringify(results, null, 2));
          console.log('Parsed test results:', JSON.stringify(results, null, 2));

          // Write to GITHUB_OUTPUT (new format, not deprecated)
          const outputPath = process.env.GITHUB_OUTPUT;
          if (outputPath) {
            fs.appendFileSync(outputPath, `total=${total}\n`);
            fs.appendFileSync(outputPath, `passed=${passed}\n`);
            fs.appendFileSync(outputPath, `failed=${failed}\n`);
            fs.appendFileSync(outputPath, `skipped=${skipped}\n`);
            fs.appendFileSync(outputPath, `duration=${Math.round(totalDuration)}\n`);
          }
          EOF
        env:
          TEST_TYPE: ${{ inputs.test_type }}

      - name: Read Parsed Results
        id: results
        if: always()
        run: |
          if [ -f parsed-test-results.json ]; then
            RESULTS=$(cat parsed-test-results.json)
            echo "results<<EOF" >> $GITHUB_OUTPUT
            echo "$RESULTS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "results={}" >> $GITHUB_OUTPUT
          fi

      - name: Send Results to Webhook
        if: always()
        run: |
          RUN_ID="${{ inputs.run_id }}"
          WEBHOOK_URL="${{ secrets.WEBHOOK_URL }}"
          WEBHOOK_SECRET="${{ secrets.WEBHOOK_SECRET }}"

          if [ -z "$WEBHOOK_URL" ] || [ -z "$WEBHOOK_SECRET" ]; then
            echo "Warning: WEBHOOK_URL or WEBHOOK_SECRET not set, skipping webhook call"
            exit 0
          fi

          TEST_TYPE="${{ inputs.test_type }}"
          STATUS="${{ job.status }}"

          # Determine final status
          if [ "$STATUS" == "success" ]; then
            FINAL_STATUS="completed"
          elif [ "$STATUS" == "failure" ] || [ "$STATUS" == "cancelled" ]; then
            FINAL_STATUS="failed"
          else
            FINAL_STATUS="completed"
          fi

          # Create test suite result
          STARTED_AT=$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")
          COMPLETED_AT=$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")

          RESULTS_JSON='{"total":0,"passed":0,"failed":0,"skipped":0,"duration":0,"results":[]}'
          if [ -f parsed-test-results.json ]; then
            RESULTS_JSON=$(cat parsed-test-results.json)
          fi

          TOTAL=$(echo "$RESULTS_JSON" | jq -r '.total // 0')
          PASSED=$(echo "$RESULTS_JSON" | jq -r '.passed // 0')
          FAILED=$(echo "$RESULTS_JSON" | jq -r '.failed // 0')
          SKIPPED=$(echo "$RESULTS_JSON" | jq -r '.skipped // 0')
          DURATION=$(echo "$RESULTS_JSON" | jq -r '.duration // 0')
          TEST_RESULTS=$(echo "$RESULTS_JSON" | jq -c '.results // []')

          PAYLOAD=$(cat <<EOF
          {
            "runId": "${RUN_ID}",
            "testResults": {
              "runId": "${RUN_ID}",
              "testType": "${TEST_TYPE}",
              "status": "${FINAL_STATUS}",
              "startedAt": "${STARTED_AT}",
              "completedAt": "${COMPLETED_AT}",
              "total": ${TOTAL},
              "passed": ${PASSED},
              "failed": ${FAILED},
              "skipped": ${SKIPPED},
              "duration": ${DURATION},
              "results": ${TEST_RESULTS},
              "markdown": ""
            }
          }
          EOF
          )

          echo "Sending webhook payload:"
          echo "$PAYLOAD" | jq '.' || echo "$PAYLOAD"

          HTTP_CODE=$(curl -s -o /tmp/webhook-response.json -w "%{http_code}" \
            -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $WEBHOOK_SECRET" \
            -d "$PAYLOAD")
          
          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            echo "✓ Webhook called successfully (HTTP $HTTP_CODE)"
            cat /tmp/webhook-response.json | jq '.' || cat /tmp/webhook-response.json
          else
            echo "⚠ Warning: Webhook call returned HTTP $HTTP_CODE"
            cat /tmp/webhook-response.json || echo "No response body"
          fi
